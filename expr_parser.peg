{
package teflon

// Convert interface{} to []interface{}
func Isl(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

}

Expr <- _ ms:MetaSelector os:ObjectSelector EOF {
  return &Expr{MetaSelector: ms.(ENode)}, nil
}

ObjectSelector <- sl:ShowSelector? ls:Level* {

  if sl == nil {
    log.Println("DEBUG: No ShowSelector.")
  } else {
    log.Println("DEBUG: ShowSelector present.")
  }

  return ls, nil
}

Level <- l:(ObjectName) '/'* {
  log.Println("DEBUG: Inside Level.")
  return l, nil
}

ShowSelector <- ss:'/'+ {
  sssl := Isl(ss)
  log.Println("DEBUG: len(sssl):", len(sssl))
  ssn := &ShowSelector{count: len(sssl)}
  return ssn, nil
}

ObjectName <- fn:( !EscapedChar [^/] / '\\' EscapeSequence )+ {
  log.Println("DEBUG: Inside FileName. fn:", string(c.text))
  onn := &ObjectName{name: string(c.text)}
  return onn, nil
}


// Meta selector selects metadata.
MetaSelector <- ms:Additive '@' _ {
  return ms, nil
}

Additive <- first:Multiplicative rest:(_ AddOp _ Multiplicative)* _ {
  n := first.(ENode)
  restSl := Isl(rest)
  for _, v := range restSl {
    vsl := Isl(v)
    op := vsl[1].(string)
    nn := vsl[3].(ENode)
    switch op{
    case "+":
      n = &AddNode{first: n, second: nn}
    case "-":
      n = &SubNode{first: n, second: nn}
    }
  }
  return n, nil
}

Multiplicative <- first:Factor rest:(_ MulOp _ Factor)* _ {
  n := first.(ENode)
  restSl := Isl(rest)
  for _, v := range restSl {
    vsl := Isl(v)
    op := vsl[1].(string)
    nn := vsl[3].(ENode)
    switch op{
    case "*":
      n = &MulNode{first: n, second: nn}
    case "/":
      n = &DivNode{first: n, second: nn}
    }
  }
  return n, nil
}

Factor <- '(' additive:Additive ')' {
    return additive, nil
} / value:Value {
    return value, nil
}

Value <- val:(String / Number / Meta) _ {
  return val, nil
}

Meta <- base:Name subs:('.' Name)* {
  m := &MetaNode{NameList: []string{base.(string)}}
	ssl := Isl(subs)
	for _, v := range ssl {
	  s := Isl(v)
		m.NameList = append(m.NameList, s[1].(string))
	}
  return m, nil
}

Name <- [\pL]+ {
  return string(c.text), nil
}

String ← '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    // TODO : the forward slash (solidus) is not a valid escape in Go, it will
    // fail if there's one in the string
    return strconv.Unquote(string(c.text))
}

EscapedChar ← [\x00-\x1f"\\]

EscapeSequence ← SingleCharEscape / UnicodeEscape

SingleCharEscape ← ["\\/bfnrt]

UnicodeEscape ← 'u' HexDigit HexDigit HexDigit HexDigit

Number ← '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    // JSON numbers have the same syntax as Go's, and are parseable using
    // strconv.
    f, err := strconv.ParseFloat(string(c.text), 64)
    return &NumberNode{Value: f}, err
}

AddOp <- ( '+' / '-' ) {
    return string(c.text), nil
}

MulOp <- ( '*' / '/' ) {
    return string(c.text), nil
}

Integer ← '0' / NonZeroDecimalDigit DecimalDigit*

Exponent ← 'e'i [+-]? DecimalDigit+

DecimalDigit ← [0-9]

HexDigit ← [0-9a-f]i

NonZeroDecimalDigit ← [1-9]

_ "whitespace" ⟵ [ \n\t\r]*

EOF <- !.
