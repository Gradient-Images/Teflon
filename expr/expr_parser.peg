{
package expr

// func main() {
//   if len(os.Args) != 2 {
//     log.Fatal("Usage: calculator 'EXPR'")
//   }
//   got, err := ParseReader("", strings.NewReader(os.Args[1]))
//   if err != nil {
//     log.Fatal(err)
//   }
//   fmt.Printf("Result: %s  Type: %T\n", got[1], got)
// }

// Convert interface{} to []interface{}
func Isl(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

}

Expr <- _ a:Additive EOF {
  return &ExprNode{MetaSelector: a.(ENode)}, nil
}

Additive <- first:Value '+' _ second:Additive {
  return &AddNode{first: first.(ENode), second: second.(ENode)}, nil
} / Value

Value <- val:(Meta / Number) _ {
  return val, nil
}

Meta <- base:Name subs:('.' Name)* {
  m := &MetaNode{NameList: []string{base.(string)}}
	ssl := Isl(subs)
	for _, v := range ssl {
	  s := Isl(v)
		m.NameList = append(m.NameList, s[1].(string))
	}
  log.Printf("DEBUG: Base: %s, Subs: %s, strSl: %s", base, subs, m)
  return m, nil
}

Name <- [\pL]+ {
  log.Printf("DEBUG: Name: %s\n", c.text)
  return string(c.text), nil
}

Number ← '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    // JSON numbers have the same syntax as Go's, and are parseable using
    // strconv.
    f, err := strconv.ParseFloat(string(c.text), 64)
    return &NumberNode{Value: f}, err
}

Integer ← '0' / NonZeroDecimalDigit DecimalDigit*

Exponent ← 'e'i [+-]? DecimalDigit+

DecimalDigit ← [0-9]

NonZeroDecimalDigit ← [1-9]

_ "whitespace" ⟵ [ \n\t\r]*

EOF <- !.
