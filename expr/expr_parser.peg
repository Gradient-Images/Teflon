{
package expr

// Convert interface{} to []interface{}
func Isl(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}

}

Expr <- _ a:Additive EOF {
  return &ExprNode{MetaSelector: a.(ENode)}, nil
}

Additive <- first:Multiplicative rest:(_ AddOp _ Multiplicative)* _ {
  n := first.(ENode)
  restSl := Isl(rest)
  for _, v := range restSl {
    vsl := Isl(v)
    op := vsl[1].(string)
    nn := vsl[3].(ENode)
    switch op{
    case "+":
      n = &AddNode{first: n, second: nn}
    case "-":
      n = &SubNode{first: n, second: nn}
    }
  }
  return n, nil
}

Multiplicative <- first:Factor rest:(_ MulOp _ Factor)* _ {
  n := first.(ENode)
  restSl := Isl(rest)
  for _, v := range restSl {
    vsl := Isl(v)
    op := vsl[1].(string)
    nn := vsl[3].(ENode)
    switch op{
    case "*":
      n = &MulNode{first: n, second: nn}
    case "/":
      n = &DivNode{first: n, second: nn}
    }
  }
  return n, nil
}

Factor <- '(' additive:Additive ')' {
    return additive, nil
} / value:Value {
    return value, nil
}

Value <- val:(Meta / Number) _ {
  return val, nil
}

Meta <- base:Name subs:('.' Name)* {
  m := &MetaNode{NameList: []string{base.(string)}}
	ssl := Isl(subs)
	for _, v := range ssl {
	  s := Isl(v)
		m.NameList = append(m.NameList, s[1].(string))
	}
  return m, nil
}

Name <- [\pL]+ {
  return string(c.text), nil
}

Number ← '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    // JSON numbers have the same syntax as Go's, and are parseable using
    // strconv.
    f, err := strconv.ParseFloat(string(c.text), 64)
    return &NumberNode{Value: f}, err
}

AddOp <- ( '+' / '-' ) {
    return string(c.text), nil
}

MulOp <- ( '*' / '/' ) {
    return string(c.text), nil
}

Integer ← '0' / NonZeroDecimalDigit DecimalDigit*

Exponent ← 'e'i [+-]? DecimalDigit+

DecimalDigit ← [0-9]

NonZeroDecimalDigit ← [1-9]

_ "whitespace" ⟵ [ \n\t\r]*

EOF <- !.
